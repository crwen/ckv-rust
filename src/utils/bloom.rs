use super::FilterPolicy;

#[allow(unused)]
#[derive(Default)]
pub struct BloomFilter {
    k: usize,
    bits_per_key: usize,
    filters: Vec<u8>,
}

impl BloomFilter {
    pub fn new(bits_per_key: usize) -> Self {
        let mut k = bits_per_key as f64 * f64::ln(2_f64);
        if k > 30f64 {
            k = 30f64;
        } else if k < 1f64 {
            k = 1f64;
        }
        Self {
            filters: Vec::new(),
            bits_per_key,
            k: k as usize,
        }
    }

    pub fn hash(data: &[u8]) -> u32 {
        let (seed, m) = (0xbc9f1d34_u32, 0xc6a4a793_u32);
        let mut h = seed ^ (m.wrapping_mul(data.len() as u32));
        let mut len = data.len();
        let mut base = 0;
        while base + 4 <= len {
            let w = (data[base] as u32)
                | (data[base + 1] as u32) << 8
                | (data[base + 2] as u32) << 16
                | (data[base + 3] as u32) << 24;
            h = h.wrapping_add(w);
            h = h.wrapping_mul(m);
            base += 4
        }
        len -= base;
        if len == 3 {
            h += (data[base + 2] as u32) << 16;
        } else if len == 2 {
            h += (data[base + 1] as u32) << 8;
        } else if len == 1 {
            h += data[base] as u32;
            h *= h.wrapping_mul(m);
            h ^= h >> 24;
        }

        h
    }

    pub fn bits_per_key(num: u32, fp: f64) -> usize {
        let size = -1.0_f64 * (num as f64) * f64::ln(fp) / (f64::ln(2_f64).powi(2));
        if size < 0_f64 {
            return 0;
        }
        f64::ceil(size / num as f64) as usize
    }
}

impl FilterPolicy for BloomFilter {
    fn may_contain(&self, filter: &[u8], key: &[u8]) -> bool {
        let n = filter.len() - 1; // exclude the k
        if filter.is_empty() || n < 1 {
            return false;
        };

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        let k = filter[n];
        if k > 30 {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        let nbits = n * 8;
        let mut h = Self::hash(key);
        let delta = (h >> 17) | (h << 15); // rotate right 17 bits

        for _ in 0..k {
            let bit_pos = h % (nbits as u32);
            if (filter[(bit_pos / 8) as usize] & (1 << (bit_pos % 8))) == 0 {
                return false;
            }
            h = h.wrapping_add(delta);
        }
        true
    }

    fn create_filter(&self, keys: &[Vec<u8>]) -> Vec<u8> {
        let mut nbits = keys.len() * self.bits_per_key;
        if nbits < 64 {
            nbits = 64;
        }
        let nbytes = (nbits + 7) / 8;
        nbits = nbytes * 8;

        let mut filter: Vec<u8> = vec![0; nbytes + 1]; // the extra place of the length bits

        for key in keys {
            let mut h = Self::hash(key.as_slice());
            let delta = (h >> 17) | (h << 15); // rotate right 17 bits
            for _ in 0..self.k {
                let bit_pos = h % (nbits as u32);
                filter[(bit_pos / 8) as usize] |= 1 << (bit_pos % 8);
                h = h.wrapping_add(delta);
            }
        }
        filter[nbytes] = self.k as u8;
        filter
    }
}

#[cfg(test)]
mod bloom_test {
    use crate::utils::FilterPolicy;

    use super::BloomFilter;

    #[test]
    fn bloom_test() {
        let mut keys = vec![];
        for i in 0..2000 {
            keys.push((i as u32).to_be_bytes().to_vec());
        }
        // let bits_per_key = Filter::bits_per_key(1000, 0.01);
        let bloom = BloomFilter::new(BloomFilter::bits_per_key(2000, 0.1));
        let filters = bloom.create_filter(&keys);
        for i in 0..2000 {
            let res = bloom.may_contain(&filters, &(i as u32).to_be_bytes());
            assert!(res);
        }
    }
}
